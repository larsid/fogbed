from fogbed.emulation import Services
from fogbed.experiment.local import FogbedExperiment
from fogbed.node.container import Container
from fogbed.resources.flavors import Resources
from fogbed.resources.models import CloudResourceModel, EdgeResourceModel
from fogbed.fails.controller import FailController
from fogbed.fails.models.availability import AvailabilityFail, AvailabilityMode # Importar AvailabilityFail e AvailabilityMode
from mininet.log import setLogLevel, info # Adicionar info para logs mais claros
import time

# Nível de log para acompanhar os eventos do Mininet
setLogLevel('info')

# Definindo os recursos máximos disponíveis no sistema
Services(max_cpu=0.5, max_mem=512)

# Criando o experimento principal
exp = FogbedExperiment()

# Criando instância EDGE
edge = exp.add_virtual_instance('edge',
    EdgeResourceModel(max_cu=2, max_mu=256))

# Criando instância CLOUD
cloud = exp.add_virtual_instance('cloud',
    CloudResourceModel(max_cu=2, max_mu=512))

# Criando os containers:

# d1: container comum sem falha
info('** [CONTAINER] Criando container d1 (sem falha)...\n')
d1 = Container('d1', resources=Resources.SMALL, ip='10.0.0.1')

# d2: container com falha de DISPONIBILIDADE
info('** [CONTAINER] Criando container d2 com falha de DISPONIBILIDADE (50% disponível, slot de 5s)...\n')
# Você pode alternar entre AvailabilityMode.CRASH e AvailabilityMode.DISCONNECT para ver os diferentes comportamentos
availability_config = AvailabilityFail(
    availability=0.5, # 50% do tempo disponível
    slot_time=5.0,      # A cada 5 segundos o estado pode mudar
    availability_mode=AvailabilityMode.DISCONNECT # Ou AvailabilityMode.CRASH
)
d2 = Container('d2',
    resources=Resources.SMALL,
    fail_model=availability_config,
    ip='10.0.0.2'
)

# d3: container comum
info('** [CONTAINER] Criando container d3 (sem falha)...\n')
d3 = Container('d3', resources=Resources.SMALL, ip='10.0.0.3')


# Alocando containers nas instâncias
info('** [ALOCAÇÃO] Alocando d1 e d2 na EDGE...\n')
exp.add_docker(d1, edge)
exp.add_docker(d2, edge)

info('** [ALOCAÇÃO] Alocando d3 na CLOUD...\n')
exp.add_docker(d3, cloud)


# Conectando as instâncias com um link de rede
info('** [REDE] Conectando EDGE e CLOUD...\n')
exp.add_link(cloud, edge)

# Criando controlador de falhas
info('** [FALHAS] Inicializando controlador de falhas...\n')
fail_controller = FailController(exp)

# Iniciando o experimento
try:
    info('** [INÍCIO] Iniciando experimento Fogbed...\n')
    exp.start()

    # Adicionando um pequeno delay para garantir que os IPs estejam configurados antes dos logs
    time.sleep(2)
    info(f"** IPs configurados: d1={d1.ip}, d2={d2.ip}, d3={d3.ip}\n")


    info('** [FALHAS] Iniciando controlador de falhas (AvailabilityFail será aplicada em d2)...\n')
    fail_controller.start()

    info(f"** [TESTE] Testando conectividade com d2 ({d2.ip}) periodicamente durante 30 segundos...\n")
    for i in range(6): # Testar por 6 * 5 = 30 segundos
        info(f"** Tentativa de ping {i+1}/6 para d2 ({d2.ip})...\n")
        ping_output = d1.cmd(f'ping -c 1 -W 1 {d2.ip}') # Ping com 1 pacote, timeout de 1 segundo
        if "1 received" in ping_output:
            info(f"** [PING {i+1}] d2 ({d2.ip}) está ACESSÍVEL.\n")
        else:
            info(f"** [PING {i+1}] d2 ({d2.ip}) está INACESSÍVEL.\n")
        # info(ping_output + "\n") # Descomente para ver a saída completa do ping
        
        # Espera o próximo slot de tempo da falha de disponibilidade
        # O log do AvailabilityCycler deve indicar a média de disponibilidade de d2
        time.sleep(5)


    info('** [INFO] Teste de disponibilidade concluído. Você pode usar o CLI para interagir com os nós...\n')
    exp.start_cli()

# Encerrando tudo corretamente
finally:
    info('** [ENCERRAMENTO] Finalizando controlador de falhas...\n')
    fail_controller.stop()

    info('** [ENCERRAMENTO] Parando experimento Fogbed...\n')
    exp.stop()

    info('** [ENCERRAMENTO] Tudo finalizado com sucesso.\n')